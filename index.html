<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AARUNYA CITY ‚Äì Smart City Portfolio</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" />

<style>
/* ========================= */
/* GLOBAL DARK THEME         */
/* ========================= */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
}
body {
  background: #0a0f1a;
  color: #e2e8f0;
  overflow-x: hidden;
}

/* ========================= */
/* NAVBAR                    */
/* ========================= */
nav {
  position: sticky;
  top: 0;
  background: #0d1627;
  padding: 18px;
  text-align: center;
  border-bottom: 2px solid #1c2d45;
  box-shadow: 0 0 12px rgba(0, 150, 255, 0.25);
  z-index: 50;
}
nav a {
  color: #cbd5e1;
  margin: 0 20px;
  font-weight: 600;
  font-size: 18px;
  text-decoration: none;
  cursor: pointer;
  transition: 0.3s;
}
nav a:hover {
  color: #4dabff;
  text-shadow: 0 0 8px #268cff;
}

/* ========================= */
/* SECTIONS                  */
/* ========================= */
.section {
  display: none;
  max-width: 1100px;
  margin: 40px auto;
  padding: 40px;
  background: #0d1627;
  border-radius: 20px;
  border: 1px solid #1e3454;
  box-shadow: 0 0 25px rgba(0, 150, 255, 0.15);
  animation: fadeIn 0.7s ease forwards;
}
.section.active {
  display: block;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ========================= */
/* TITLES                    */
/* ========================= */
.title {
  text-align: center;
  font-size: 34px;
  margin-bottom: 25px;
  color: #ffb703;
  text-shadow: 0 0 8px rgba(255, 183, 3, 0.4);
}
.desc {
  text-align: center;
  font-size: 19px;
  max-width: 750px;
  margin: auto;
  line-height: 1.6;
  color: #cbd5e1;
}

/* ========================= */
/* DARK GLOW PROFILE CARDS   */
/* ========================= */
.profile-container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 25px;
}
.profile-box {
  background: #0b1320;
  border: 1px solid #1e3454;
  border-radius: 15px;
  padding: 25px;
  width: 260px;
  text-align: center;
  box-shadow: 0 0 18px rgba(0, 140, 255, 0.18);
  transition: 0.3s;
}
.profile-box:hover {
  transform: translateY(-6px);
  box-shadow: 0 0 35px rgba(0, 140, 255, 0.35);
}
.profile-box img {
  width: 110px;
  height: 110px;
  border-radius: 50%;
  border: 3px solid #268cff;
  margin-bottom: 15px;
}

/* ========================= */
/* DARK GLOW IDEA CARDS      */
/* ========================= */
.ideas-container {
  display: flex;
  flex-wrap: wrap;
  gap: 18px;
  justify-content: center;
}
.idea-box {
  flex: 0 1 270px;
  background: #0b1320;
  border: 1px solid #1e3454;
  box-shadow: 0 0 15px rgba(38, 140, 255, 0.18);
  padding: 15px 20px;
  border-radius: 12px;
  color: #e2e8f0;
  font-size: 17px;
  display: flex;
  align-items: center;
  gap: 12px;
  transition: 0.3s;
  cursor: pointer;
}
.idea-box:hover {
  background: #0f1e33;
  box-shadow: 0 0 28px rgba(38, 140, 255, 0.35);
  transform: translateY(-5px);
}
.idea-box span {
  font-size: 24px;
}

/* Ankita detail card (pop-up) */
.ankita-card {
  margin-top: 30px;
  background: linear-gradient(180deg, rgba(9,18,30,0.95), rgba(6,12,22,0.95));
  border: 1px solid #265f9a;
  box-shadow: 0 8px 40px rgba(2,60,120,0.45);
  padding: 24px;
  border-radius: 14px;
  color: #dbeafe;
}
.ankita-card h2{ color:#ffde59; margin-bottom:6px; }
.ankita-card .sub { color:#9fb7d9; margin-bottom:12px; }
.ankita-grid {
  display:grid;
  grid-template-columns: 1fr;
  gap:12px;
}
.meta { display:flex; gap:16px; flex-wrap:wrap; }
.meta .chip {
  background:#051425; border:1px solid #2b6ea3; padding:8px 12px; border-radius:10px;
  color:#bfe1ff;
}
.section-code { background:#001218; border:1px solid #0f5a86; padding:12px; border-radius:10px; color:#9fffbf; font-family:monospace; white-space:pre; overflow:auto; max-height:340px; }
.small { font-size:14px; color:#bcd7f3; }
.note { font-size:14px; color:#c8e6ff; }

/* RESPONSIVE */
@media (max-width: 600px) {
  .idea-box { flex: 1 1 100%; }
  .profile-container { flex-direction: column; align-items: center; }
  .section { padding:20px; margin:20px; }
}
</style>
</head>

<body>

<!-- ========================= -->
<!-- NAVIGATION BAR            -->
<!-- ========================= -->
<nav>
  <a onclick="showPage('home')">Home</a>
  <a onclick="showPage('about')">About</a>
  <a onclick="showPage('project')">Project</a>
  <a onclick="showPage('arbiya')">Arbiya Naaz</a>
  <a onclick="showPage('akshata')">Akshata</a>
  <a onclick="showPage('ankita')">Ankita</a>
  <a onclick="showPage('sai')">Sai</a>
</nav>

<!-- ========================= -->
<!-- HOME PAGE                 -->
<!-- ========================= -->
<section id="home" class="section active">
  <h1 class="title">WELCOME TO AARUNYA CITY</h1>
  <p class="desc">
    A futuristic smart city powered by innovation, technology, and sustainable development.
  </p>
</section>

<!-- ========================= -->
<!-- ABOUT TEAM                -->
<!-- ========================= -->
<section id="about" class="section">
  <h1 class="title">Meet Our Team</h1>
  <div class="profile-container">

    <div class="profile-box">
      <img src="https://i.ibb.co/3R0WfKP/user.png" alt="Arbiya">
      <h3>Arbiya Naaz</h3>
      <p>USN: 01FE24BCS042</p>
      <p><b>Skills:</b> C, C++, DSA</p>
      <p>Works on algorithms and data structuring.</p>
    </div>

    <div class="profile-box">
      <img src="https://i.ibb.co/3R0WfKP/user.png" alt="Akshata">
      <h3>Akshata</h3>
      <p>USN: 01FE24BCS150</p>
      <p><b>Skills:</b> C, C++, DSA</p>
      <p>Handles front-end and creative ideation.</p>
    </div>

    <div class="profile-box">
      <img src="https://i.ibb.co/3R0WfKP/user.png" alt="Ankita">
      <h3>Ankita</h3>
      <p>USN: 01FE24BCS146</p>
      <p><b>Skills:</b> C, C++, DSA</p>
      <p>Manages back-end logic and simulations.</p>
    </div>

    <div class="profile-box">
      <img src="https://i.ibb.co/3R0WfKP/user.png" alt="Sai">
      <h3>Sai</h3>
      <p>USN: 01FE24BCS160</p>
      <p><b>Skills:</b> C, C++, DSA</p>
      <p>Focuses on AI, optimization, and analytics.</p>
    </div>

  </div>
</section>

<!-- ========================= -->
<!-- PROJECT OVERVIEW          -->
<!-- ========================= -->
<section id="project" class="section">
  <h1 class="title">AARUNYA CITY ‚Äì Project Overview</h1>
  <p class="desc">
    Aarunya City is a futuristic sustainable metropolitan ecosystem integrating AI,
    automation, clean energy, innovation, and modern urban planning.
  </p>
</section>

<!-- ========================= -->
<!-- ARBIYA PAGE               -->
<!-- ========================= -->
<section id="arbiya" class="section">
  <h1 class="title">Arbiya Naaz ‚Äì Business Ideas</h1>

  <div class="ideas-container">
    <div class="idea-box"><span>‚ö°</span> Logistics Hub</div>
    <div class="idea-box"><span>üèï</span> Eco Resort</div>
    <div class="idea-box"><span>üíª</span> IT Training Center</div>
    <div class="idea-box"><span>‚ùÑ</span> Cold Storage</div>
    <div class="idea-box"><span>üè¢</span> Co-working Hub</div>
    <div class="idea-box"><span>üõç</span> Retail Mall</div>
    <div class="idea-box"><span>üè•</span> Multi-specialty Hospital</div>
    <div class="idea-box"><span>‚ö°</span> EV Charging</div>
    <div class="idea-box"><span>üö§</span> Waterfront Tourism</div>
    <div class="idea-box"><span>üì¶</span> E-commerce Center</div>
  </div>

</section>

<!-- ========================= -->
<!-- AKSHATA PAGE              -->
<!-- ========================= -->
<section id="akshata" class="section">
  <h1 class="title">Akshata ‚Äì Business Ideas</h1>

  <div class="ideas-container">
    <div class="idea-box"><span>ü¶æ</span> Floating Micro-Farms</div>
    <div class="idea-box"><span>üõí</span> XR Hologram Shops</div>
    <div class="idea-box"><span>üéµ</span> AI Sound Trails</div>
    <div class="idea-box"><span>üö¥‚Äç‚ôÇ</span> Energy-Bike Caf√©</div>
    <div class="idea-box"><span>‚è≥</span> Simulation Pods</div>
    <div class="idea-box"><span>üß±</span> Eco-Bricks</div>
    <div class="idea-box"><span>üó∫</span> Scent Navigation Maps</div>
    <div class="idea-box"><span>üöÅ</span> Drone Dining</div>
    <div class="idea-box"><span>üåà</span> Smart Sidewalks</div>
    <div class="idea-box"><span>üßò‚Äç‚ôÄ</span> Meditation Pods</div>
  </div>

</section>

<!-- ========================= -->
<!-- ANKITA PAGE (UPGRADED)    -->
<!-- ========================= -->
<section id="ankita" class="section">
  <h1 class="title">Ankita ‚Äì Business Ideas</h1>

  <p class="desc">Click an idea to see: SDG alignment, the DAA algorithms from your syllabus that apply, design philosophy, complexity analysis and a ready-to-run C++ implementation (map/graph based where appropriate), plus explanation.</p>

  <div class="ideas-container" id="ankitaIdeas">
    <div class="idea-box" onclick="openAnkita(1)"><span>üè•</span> Smart Healthcare & Emergency Routing</div>
    <div class="idea-box" onclick="openAnkita(2)"><span>‚ö°üíß</span> Smart Water‚ÄìEnergy Optimization Grid</div>
    <div class="idea-box" onclick="openAnkita(3)"><span>‚ôª</span> Intelligent Waste Management</div>
    <div class="idea-box" onclick="openAnkita(4)"><span>üéìüìö</span> Personalized Learning Platform</div>
    <div class="idea-box" onclick="openAnkita(5)"><span>üö¶üöå</span> Smart Traffic Management</div>
    <div class="idea-box" onclick="openAnkita(6)"><span>üõ°üé•</span> Security & Surveillance Hub</div>
    <div class="idea-box" onclick="openAnkita(7)"><span>üåæüöú</span> Smart Farming Network</div>
    <div class="idea-box" onclick="openAnkita(8)"><span>‚úàüöâüöó</span> Multi-Modal Transport System</div>
    <div class="idea-box" onclick="openAnkita(9)"><span>üõíüì¶</span> Supply Chain Optimization</div>
    <div class="idea-box" onclick="openAnkita(10)"><span>üß†üíª</span> Cyber-Tech Innovation Lab</div>
  </div>

  <!-- Pop-up card -->
  <div id="ankitaCard" class="ankita-card" style="display:none;"></div>
</section>

<!-- ========================= -->
<!-- SAI PAGE                  -->
<!-- ========================= -->
<section id="sai" class="section">
  <h1 class="title">Sai ‚Äì Business Ideas</h1>

  <div class="ideas-container">
    <div class="idea-box"><span>üîã</span> Smart Energy Grid</div>
    <div class="idea-box"><span>üöö</span> Autonomous Port Logistics</div>
    <div class="idea-box"><span>üõ∞</span> Satellite-IoT Monitoring</div>
    <div class="idea-box"><span>üõ°</span> Cybersecurity Intelligence</div>
    <div class="idea-box"><span>üö¶</span> Smart Mobility Control</div>
    <div class="idea-box"><span>üöê</span> Autonomous Shuttle Pods</div>
    <div class="idea-box"><span>üß†</span> Neural Simulation Lab</div>
    <div class="idea-box"><span>üè•</span> AI Healthcare Prediction</div>
    <div class="idea-box"><span>üí°</span> Smart Lighting Network</div>
    <div class="idea-box"><span>üìä</span> Data Commerce Hub</div>
  </div>

</section>

<script>
function showPage(id) {
  document.querySelectorAll('.section').forEach(sec => sec.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  window.scrollTo({top:0, behavior:'smooth'});
}

/* =========================
   Data for Ankita ideas
   ========================= */
const ankitaData = {
  1: {
    title: "Smart Healthcare & Emergency Routing",
    sdg: "SDG 3 ‚Äì Good Health & Well-Being",
    algorithms: [
      "Graphs & Shortest Path (Dijkstra, Bellman-Ford)",
      "Floyd-Warshall (all-pairs for precomputed times)",
      "Heaps/Priority Queue (for Dijkstra)",
      "Hashing/Maps (store nodes/labels)",
      "Segment trees / Fenwick (if we need fast updates of traffic weights)"
    ],
    design: `Design Philosophy & Intuition:
- Model city intersections as graph nodes and roads as weighted edges (weight = travel time).
- Ambulatory routing needs fastest path under dynamic conditions (traffic). Dijkstra suits live shortest-path on non-negative weights; Bellman-Ford handles negative edge weights (rare for travel times).
- Keep routing incremental: precompute when possible (Floyd-Warshall for small networks), otherwise run Dijkstra with up-to-date weights.`,

    complexity: `Time & Space Complexity:
- Dijkstra using binary heap: O((V + E) log V)
- Bellman-Ford: O(V * E)
- Floyd-Warshall (precompute): O(V^3)
Space: O(V + E) for adjacency lists.`,
    primary_code_title: "Dijkstra (map + priority_queue) ‚Äî C++",
    primary_code: `// Dijkstra using map<string, vector<pair<string,int>>> for city map
#include <bits/stdc++.h>
using namespace std;

using pii = pair<int,string>;
map<string, vector<pair<string,int>>> graph;

void addEdge(const string &u, const string &v, int w) {
    graph[u].push_back({v,w});
    graph[v].push_back({u,w}); // undirected
}

map<string,int> dijkstra(const string &src) {
    const int INF = 1e9;
    map<string,int> dist;
    for (auto &kv : graph) dist[kv.first] = INF;
    dist[src] = 0;

    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, src});

    while(!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for(auto &edge : graph[u]) {
            string v = edge.first;
            int w = edge.second;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}

int main(){
    addEdge(\"Hospital\", \"J1\", 4);
    addEdge(\"J1\", \"A1\", 6);
    addEdge(\"Hospital\", \"A2\", 10);
    addEdge(\"A1\", \"A2\", 2);
    auto dist = dijkstra(\"Hospital\");
    cout << \"Time from Hospital:\\n\";
    for(auto &p: dist) cout << p.first << \" : \" << p.second << \" mins\\n\";
    return 0;
}

/* Sample output:
Time from Hospital:
Hospital : 0 mins
J1 : 4 mins
A1 : 10 mins
A2 : 12 mins
*/`,

    explanation: `Why this fits the idea:
- Fastest routing saved lives. Dijkstra + map lets us label intersections with strings (useful for real city names).
- For time-varying traffic weights, re-run Dijkstra on updated weights or use incremental approaches.
Related syllabus topics used: Graphs, Priority Queues (Heap), Maps, Dijkstra, Floyd-Warshall, Bellman-Ford (if negative adjustments).`
  },

  2: {
    title: "Smart Water‚ÄìEnergy Optimization Grid",
    sdg: "SDG 7 ‚Äì Affordable & Clean Energy",
    algorithms: [
      "Minimum Spanning Tree (Prim / Kruskal) ‚Äî to connect substations with minimal cable/cost",
      "Greedy + Flow algorithms (max-flow min-cost for distribution)",
      "Dynamic Programming for scheduling and demand prediction"
    ],
    design: `Design Philosophy:
- Represent nodes as substations/water plants; edges have cost (installation + loss).
- Build MST (Prim/Kruskal) to minimize infrastructure cost. For load balancing, use flow algorithms.`,
    complexity: `Complexities:
- Prim (with heap): O((V + E) log V)
- Kruskal (sort edges): O(E log E)
- Max-flow (Edmonds-Karp): O(V * E^2) ‚Äî use Dinic for speed.`,
    primary_code_title: "Prim (map + priority_queue) ‚Äî C++ (skeleton)",
    primary_code: `// Prim using adjacency map<string, vector<pair<string,int>>>
#include <bits/stdc++.h>
using namespace std;
map<string, vector<pair<string,int>>> graph;

void addEdge(const string &u, const string &v, int w){
    graph[u].push_back({v,w});
    graph[v].push_back({u,w});
}

int prim(const string &start) {
    unordered_map<string, bool> inMST;
    unordered_map<string, int> key;
    for (auto &kv: graph) key[kv.first] = INT_MAX;
    key[start] = 0;
    // min-heap of (key,node)
    priority_queue<pair<int,string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;
    pq.push({0,start});
    int totalCost = 0;
    while(!pq.empty()){
        auto [k,u] = pq.top(); pq.pop();
        if (inMST[u]) continue;
        inMST[u]=true;
        totalCost += k;
        for(auto &edge: graph[u]){
            string v = edge.first; int w = edge.second;
            if(!inMST[v] && w < key[v]){
                key[v]=w; pq.push({w,v});
            }
        }
    }
    return totalCost;
}

// usage: add edges, call prim("NodeA");
`,
    explanation: `Why this fits:
- MST reduces total infrastructure cost for connecting distributed resources.
Syllabus relations: MST (Prim/Kruskal), Greedy strategies, Graphs, Heaps.`
  },

  3: {
    title: "Intelligent Waste Management",
    sdg: "SDG 11 ‚Äì Sustainable Cities & Communities",
    algorithms: [
      "Greedy (nearest pickup), Vehicle Routing heuristics (VRP, approximation)",
      "Graph traversal (BFS/DFS) for coverage",
      "K-Means / clustering (not in DAA core but relevant) for zone assignment"
    ],
    design: `Design Philosophy:
- Model collection points as nodes; use greedy nearest-neighbour or heuristic VRP to assign vans.
- For frequent recalculation, use greedy + local improvements (2-opt).`,
    complexity: `Typical complexities:
- Greedy nearest: O(V^2) naive; with spatial indexing can be improved.
- VRP heuristics vary.`,
    primary_code_title: "Greedy nearest (map-based skeleton) ‚Äî C++",
    primary_code: `// Simple greedy nearest for demonstration (not optimal VRP)
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,string>;
map<string, pair<int,int>> coords; // name -> (x,y)
set<string> unvisited;

int dist(const pair<int,int>& a, const pair<int,int>& b){
    return abs(a.first-b.first) + abs(a.second-b.second);
}

vector<string> greedyRoute(const string &start){
    vector<string> route;
    string cur = start; route.push_back(cur);
    unvisited.erase(cur);
    while(!unvisited.empty()){
        int bestD = INT_MAX; string best="";
        for(auto &n : unvisited){
            int d = dist(coords[cur], coords[n]);
            if(d < bestD){ bestD = d; best = n; }
        }
        cur = best; route.push_back(cur); unvisited.erase(cur);
    }
    return route;
}

// Populate coords and unvisited, call greedyRoute("Depot");
`,
    explanation: `Why this fits:
- Practical and simple for quick routing of pickup vans.
Syllabus relations: Greedy algorithms, Graphs (coverage), complexity analysis; for improved solutions study VRP & heuristics.`
  },

  4: {
    title: "Personalized Learning Platform (EdTech)",
    sdg: "SDG 4 ‚Äì Quality Education",
    algorithms: [
      "Dynamic Programming (recommendation scoring, sequence optimization)",
      "Trie/Hashing (fast lookup for keywords/quiz banks)",
      "KMP / Rabin-Karp (text matching for plagiarism / content search)",
      "Collaborative filtering (matrix factorization ‚Äî relates to linear algebra)"
    ],
    design: `Design Philosophy:
- Model student state as progress vector; use DP to compute best next modules (maximize learning gain given time).
- Use tries/hashing for fast content search and KMP for substring matches in text analysis.`,
    complexity: `DP path computations depend on state size; Tries: O(L) per lookup where L is key length.`,
    primary_code_title: "DP ‚Äî simple learning path scoring (C++ skeleton)",
    primary_code: `// Simple DP: choose sequence of modules maximizing score under time budget
#include <bits/stdc++.h>
using namespace std;

struct Module{ int id; int time; int gain; };
int knapsackDP(vector<Module>& mods, int T){
    int n = mods.size();
    vector<int> dp(T+1,0);
    for(auto &m : mods){
        for(int t=T; t>=m.time; --t)
            dp[t] = max(dp[t], dp[t-m.time] + m.gain);
    }
    return dp[T];
}

// Use knapsack style DP to select modules under time budget.
`,
    explanation: `Why this fits:
- Personalization is resource-constrained optimization ‚Äî classic knapsack/DP pattern.
Syllabus relations: DP, Knapsack, Tries, KMP, Hashing.`
  },

  5: {
    title: "Smart Traffic Management",
    sdg: "SDG 9 ‚Äì Industry, Innovation & Infrastructure",
    algorithms: [
      "Dijkstra / A* (shortest path + heuristics)",
      "BFS for unweighted routing",
      "Segment Trees / Fenwick for range queries (traffic volumes)",
      "Heap + dynamic updates"
    ],
    design: `Design Philosophy:
- Use weighted graphs with dynamic edge weights (traffic). For fastest rerouting, Dijkstra; for predicted routing, A* with heuristic (distance estimate).`,
    complexity: `Dijkstra: O((V+E) log V). A*: similar but faster with good heuristic.`,
    primary_code_title: "A* style skeleton (uses heuristic) ‚Äî C++ (concept)",
    primary_code: `// A* skeleton for transport (conceptual)
#include <bits/stdc++.h>
using namespace std;
// Node coords for heuristic (euclidean)
map<string, pair<int,int>> coords;
map<string, vector<pair<string,int>>> graph;

double heuristic(const string &a, const string &b){
    auto pa = coords[a], pb = coords[b];
    double dx = pa.first - pb.first, dy = pa.second - pb.second;
    return sqrt(dx*dx + dy*dy); // euclidean
}

// Full A* implementation omitted for brevity ‚Äî same pattern with open/closed sets and f=g+h
`,
    explanation: `Why this fits:
- A* combines shortest-path with heuristic for fast route planning.
Syllabus relations: Graphs, A* (informed search extension), BFS/DFS, segment tree for analytics.`
  },

  6: {
    title: "Security & Surveillance Hub",
    sdg: "SDG 16 ‚Äì Peace, Justice & Strong Institutions",
    algorithms: [
      "KMP / Rabin-Karp (pattern matching in CCTV logs / text)",
      "Trie & Hashing (fast lookup of known patterns)",
      "Graph search + clustering for suspicious movement patterns",
      "Heap & sliding-window for anomaly detection"
    ],
    design: `Design Philosophy:
- Use pattern matching to find suspicious text patterns, object tracking via graph clustering, and hashing/trie for quick lookups of watchlists.`,
    complexity: `KMP: O(n+m) for text search. Hash/trie lookups: O(L).`,
    primary_code_title: "KMP pattern matching ‚Äî C++",
    primary_code: `#include <bits/stdc++.h>
using namespace std;
vector<int> buildLPS(const string &pat){
    int m = pat.size();
    vector<int> lps(m);
    int len=0,i=1;
    while(i<m){
        if(pat[i]==pat[len]) lps[i++] = ++len;
        else if(len) len = lps[len-1];
        else lps[i++] = 0;
    }
    return lps;
}
vector<int> kmpSearch(const string &txt, const string &pat){
    vector<int> lps = buildLPS(pat);
    vector<int> occ;
    int i=0,j=0;
    while(i < (int)txt.size()){
        if(txt[i]==pat[j]){ i++; j++; if(j==pat.size()){ occ.push_back(i-j); j=lps[j-1]; } }
        else if(j) j = lps[j-1];
        else i++;
    }
    return occ;
}
int main(){
    string text = \"camera_log_suspicious_movement\"; 
    string pat = \"suspicious\";
    auto occ = kmpSearch(text, pat);
    for(int idx: occ) cout<<\"Found at \"<<idx<<\"\\n\";
    return 0;
}
`,
    explanation: `Why this fits:
- Fast string search across logs and real-time streams helps flag events quickly.
Syllabus relations: KMP, Rabin-Karp, Tries, Hashing, pattern matching.`
  },

  7: {
    title: "Smart Farming Network",
    sdg: "SDG 2 ‚Äì Zero Hunger",
    algorithms: [
      "Greedy & DP (crop scheduling and resource allocation)",
      "Segment Trees / Fenwick for range queries of sensor data",
      "Heaps for priority irrigation scheduling"
    ],
    design: `Design Philosophy:
- Combine sensor data with optimization: DP for planting schedules (maximize yield), greedy for daily resource allocation.`,
    complexity: `DP / Greedy vary by state size; typical DP O(n*T) where T is time budget.`,
    primary_code_title: "Greedy + DP skeleton (knapsack style) ‚Äî C++",
    primary_code: `// Farm scheduling: choose set of crops under water budget (knapsack-like)
#include <bits/stdc++.h>
using namespace std;
struct Crop{ int water; int yield; };
int farmDP(vector<Crop>& crops, int W){
    vector<int> dp(W+1,0);
    for(auto &c: crops){
        for(int w=W; w>=c.water; --w)
            dp[w] = max(dp[w], dp[w-c.water] + c.yield);
    }
    return dp[W];
}
`,
    explanation: `Why this fits:
- Resource constrained optimization -> DP (knapsack family).
Syllabus ties: Knapsack, DP, Greedy, Fenwick/Segment trees for sensor analytics.`
  },

  8: {
    title: "Multi-Modal Transport System",
    sdg: "SDG 11 ‚Äì Sustainable Cities",
    algorithms: [
      "Multi-graph shortest paths (Dijkstra on combined networks)",
      "Floyd-Warshall for medium-size networks (all pairs)",
      "TSP approximations (route planning for shuttles)"
    ],
    design: `Design Philosophy:
- Combine bus/rail/air nodes into a multi-layer graph. Compute best combination path using shortest-path on layered graph.`,
    complexity: `Dijkstra per source: O((V+E)logV); Floyd-Warshall O(V^3) if precompute.`,
    primary_code_title: "Dijkstra on layered graph ‚Äî C++ (map-based)",
    primary_code: `// Multi-modal: nodes include mode prefix, e.g., "bus_A", "train_B"
#include <bits/stdc++.h>
using namespace std;
map<string, vector<pair<string,int>>> graph;
void addEdge(string u,string v,int w){ graph[u].push_back({v,w}); graph[v].push_back({u,w}); }
map<string,int> dijkstra(string src){
    const int INF=1e9; map<string,int> dist; for(auto &kv:graph) dist[kv.first]=INF;
    dist[src]=0; priority_queue<pair<int,string>,vector<pair<int,string>>, greater<pair<int,string>>> pq;
    pq.push({0,src});
    while(!pq.empty()){
        auto [d,u]=pq.top();pq.pop();
        if(d!=dist[u]) continue;
        for(auto &e:graph[u]){
            if(dist[e.first] > d + e.second){
                dist[e.first] = d + e.second;
                pq.push({dist[e.first], e.first});
            }
        }
    }
    return dist;
}
// Build layered graph, call dijkstra("bus_A_start");
`,
    explanation: `Why this fits:
- Multi-modal optimization is naturally a layered graph shortest-path problem.
Syllabus: Graphs, Dijkstra, Floyd-Warshall, TSP heuristics.`
  },

  9: {
    title: "Supply Chain & Logistics Optimization",
    sdg: "SDG 8 ‚Äì Decent Work & Economic Growth",
    algorithms: [
      "Knapsack & DP (packing & resource allocation)",
      "TSP & Vehicle Routing heuristics",
      "Greedy for heuristics, hashing/maps for inventory lookups",
      "Min-cost max-flow for cost-optimized distribution"
    ],
    design: `Design Philosophy:
- Use DP/Knapsack to select load under constraints; use TSP/VRP heuristics for route planning and min-cost flow for distribution.`,
    complexity: `Knapsack DP O(n * capacity), TSP exact exponential (use heuristics/approx).`,
    primary_code_title: "0/1 Knapsack (DP) ‚Äî C++",
    primary_code: `#include <bits/stdc++.h>
using namespace std;
int knapsack(vector<int>& wt, vector<int>& val, int W){
    int n = wt.size();
    vector<int> dp(W+1,0);
    for(int i=0;i<n;i++){
        for(int w=W; w>=wt[i]; --w)
            dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);
    }
    return dp[W];
}
int main(){
    vector<int> wt = {3,4,6}, val = {4,5,8};
    int W = 10;
    cout<<\"Max value: \"<<knapsack(wt,val,W)<<\"\\n\";
    return 0;
}`,
    explanation: `Why this fits:
- Knapsack models packing vehicles under capacity constraints.
Syllabus: Knapsack, DP, TSP, Flow algorithms.`
  },

  10: {
    title: "Cyber-Tech Innovation Lab",
    sdg: "SDG 9 ‚Äì Industry, Innovation & Infrastructure",
    algorithms: [
      "Hashing, Tries (fast lookup), Heaps (priority jobs)",
      "Graphs + search patterns for attack surface mapping",
      "Huffman coding for compression, Strassen for fast matrix mult (research)",
      "Complex topics: P vs NP, Undecidability for theory studies"
    ],
    design: `Design Philosophy:
- Provide a sandbox for algorithms: indexing (tries, hashing), compression (Huffman), large-matrix ops (Strassen), security graph analytics (graph algorithms).`,
    complexity: `Varies: Hash lookup O(1) average, Trie O(L), Huffman build O(n log n), Strassen ~ O(n^2.8).`,
    primary_code_title: "Trie (prefix lookup) ‚Äî C++",
    primary_code: `#include <bits/stdc++.h>
using namespace std;
struct Trie {
    bool end=false;
    unordered_map<char, Trie*> next;
};
void insertWord(Trie* root, const string &s){
    Trie* cur=root;
    for(char c: s){
        if(!cur->next[c]) cur->next[c] = new Trie();
        cur = cur->next[c];
    }
    cur->end = true;
}
bool searchWord(Trie* root, const string &s){
    Trie* cur=root;
    for(char c: s){
        if(!cur->next[c]) return false;
        cur = cur->next[c];
    }
    return cur->end;
}
int main(){
    Trie* root = new Trie();
    insertWord(root, \"encrypt\");
    insertWord(root, \"analyze\");
    cout << searchWord(root, \"encrypt\") << \"\\n\"; // 1
    cout << searchWord(root, \"enc\") << \"\\n\"; // 0
    return 0;
}`,
    explanation: `Why this fits:
- Cyber lab needs fast text/indexing for threat signatures and experimentation with algorithms across DSA syllabus.
Syllabus: Tries, Hashing, Huffman, Strassen, P vs NP discussion for research-level insights.`
  }
};

/* =========================
   Render function for Ankita card
   ========================= */
function openAnkita(id){
  const d = ankitaData[id];
  const card = document.getElementById('ankitaCard');
  card.style.display = 'block';
  card.innerHTML = `
    <h2>${d.title}</h2>
    <div class="sub">SDG: <b>${d.sdg}</b></div>
    <div class="meta">
      <div class="chip">Primary algorithms: ${d.algorithms[0]}</div>
      <div class="chip">Related topics: ${d.algorithms.slice(1).join(', ')}</div>
    </div>

    <div style="margin-top:12px;" class="small"><b>Design Philosophy & Intuitions</b></div>
    <div class="note">${d.design}</div>

    <div style="margin-top:10px;" class="small"><b>Space & Time Complexities</b></div>
    <div class="note">${d.complexity}</div>

    <div style="margin-top:10px;" class="small"><b>Primary C++ Implementation (${d.primary_code_title})</b></div>
    <div class="section-code">${escapeHtml(d.primary_code)}</div>

    <div style="margin-top:10px;" class="small"><b>Explanation (student POV)</b></div>
    <div class="note">${d.explanation}</div>
  `;
  // scroll to card smoothly
  setTimeout(()=> card.scrollIntoView({behavior:'smooth', block:'center'}),80);
}

/* escape HTML for code display */
function escapeHtml(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/* Initialize: keep Home active by default */
document.addEventListener('DOMContentLoaded', ()=>{ showPage('home'); });

</script>

</body>
</html>
